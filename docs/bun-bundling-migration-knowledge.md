# Bun Bundling Migration Knowledge Map

This document captures the information we need before converting the Vite-based frontend bundles (client app, UI library, marketing site) to Bun's bundler and serving the UI directly from the Bun server with hot reloading.

## 1. Baseline Architecture We Must Preserve

### Client App (`packages/client`)
- Entry points: `index.html` + React 19 routes generated by `@tanstack/router-plugin`. Need equivalents for auto route tree generation and code splitting. See `packages/client/vite.config.ts` for plugin orchestration and build output targeting `../server/client-dist`.
- Custom Vite plugins: PWA setup, `tsconfigPaths`, a type-only import enforcement plugin, and an aggressive backend import blocker. Confirm Bun bundler equivalents or rewrites.
- Rollup-driven build settings: manual chunks for `mermaid`, `optimizeDeps` include/exclude, commonjs handling, asset size limits, and environment prefixes.
- Dev server behavior: strict port 1420, auto-open browser, fallback SPA routing, and optional inspector tooling controlled via env vars.

### UI Library (`packages/ui`)
- Library mode build producing ESM + CJS outputs with CSS injection (`vite-plugin-lib-inject-css`) and PostCSS pipeline. Bundler must support library builds, dual module formats, and side-effect CSS emission.
- Alias resolution (`@`, `@components`) and extension resolution; expectation of CSS bundling into `dist/index.css` with `postcss` follow-up.
- External peer dependency list maintained via Rollup externals—need to map to Bun bundler externals configuration.

### Marketing Website (`packages/website`)
- React/TanStack Router SPA with extensive Rollup output customization: manual chunk splitting per dependency family, asset naming conventions, gzip/brotli compression via plugins, bundle visualizer, and PWA configuration.
- Dev server on port 5173; environment toggles for analysis reports; `optimizeDeps` pre-bundle list referencing `@promptliano/ui`.

### Server Integration (`packages/server/server.ts`)
- Serves prebuilt static assets from `client-dist` and proxies `/api` routes via Hono. Dev/prod split is currently where dev expects assets under `packages/server/client-dist`.
- Hot reloading currently supplied by Vite dev server proxy; Bun server simply serves static build output.
- Startup scripts (`scripts/start-dev.ts`, etc.) spawn separate processes for server and Vite dev server. Need to understand lifecycle to collapse into a single Bun process.

## 2. Bun Bundler Capability Questions

We must catalogue Bun bundler features and gaps that map to the current Vite/Rollup setup:
- **Plugin parity**: Does Bun's bundler offer hooks comparable to Vite/Rollup for:
  - React SWC transform (or Bun-native JSX pipeline) with React 19 features.
  - TanStack Router file watching & route tree generation (or alternative build step).
  - PWA manifest/service worker generation and Workbox runtime caching equivalents.
  - Compression artifacts (gzip/brotli) and bundle visualization outputs.
  - CSS injection for libraries and PostCSS integration.
  - Custom plugin logic (blocking specific imports, enforcing type-only usage).
- **Library builds**: Confirm support for emitting both ESM and CJS bundles, control over `preserveModules`, `inlineDynamicImports`, and custom asset naming.
- **Manual chunking / code splitting**: Need to know how to express manual chunk boundaries, vendor splitting, and chunk naming in Bun.
- **Env handling**: Equivalent to Vite's `envPrefix`, `import.meta.env`, and runtime environment variable injection.
- **Path alias / module resolution**: How to replicate `tsconfigPaths` and alias falsy modules (used to block backend imports in the client bundle).
- **CommonJS & legacy packages**: Strategy for packages that expect Rollup's `commonjsOptions.include` behavior (`mermaid`, `d3`).
- **Asset pipeline**: Static asset handling, hashed filenames, CSS code splitting, and sourcemap control matching our current outputs.
- **Dev server & HMR**: Bun dev server/HMR APIs, React Fast Refresh equivalent, port configuration, websocket transport, and integration with Bun's `serve()`.

## 3. Workspace-Specific Migration Notes

### Client App
- Investigate how to regenerate TanStack Router `routeTree.gen.ts` without Vite's plugin—possibly via dedicated CLI or a Bun watcher.
- Replace Vite PWA plugin capabilities: manifest generation, Workbox config (runtime caching, glob patterns, max file sizes), and development service worker toggles.
- Recreate custom import guard plugins within Bun (likely via separate lint/build step if bundler lacks hooks).
- Maintain existing build artifacts expected by server (`../server/client-dist` structure, `index.html`, hashed JS/CSS assets).
- Understand Playwright E2E pipeline implications when dev server changes—update `test:e2e` scripts if they rely on Vite dev server behavior.

### UI Library
- Ensure Bun bundler can output library bundles without bundling peer dependencies. Need configuration for externals and CSS asset writing to `dist/index.css`.
- Validate compatibility of `postcss` CLI step post-bundle; consider integrating PostCSS via Bun if supported.
- Handle watch mode equivalent to `vite build --watch` for `bun --watch` or custom script.

### Website
- Identify replacements for compression plugin outputs (pre-generating `.gz`/`.br`). Bun may need manual post-build steps.
- Determine how to handle analytics toggle (`ANALYZE`) for visualization reports—can Bun generate bundle stats or do we need third-party tooling?
- Confirm TanStack Router plugin alternative for route tree generation and auto code splitting.

## 4. Unified Server + Bundler Strategy

To serve the client directly from the Bun server with hot reloading and collapse dev/prod differences:
- Understand Bun's new bundler/watch APIs (e.g., `Bun.build` + `Bun.serve`) and whether they support in-memory builds feeding responses.
- Plan HMR wiring: WebSocket upgrades, file watching, and invalidation flows inside `packages/server/server.ts` without relying on Vite.
- Decide how to handle multi-app hosting (client, website) when served from the same Bun process—routing strategy, asset namespaces, deployment layout.
- Evaluate whether we can bundle on-the-fly per request (streaming) or need background build/watchers writing to disk similar to Vite.
- Update `scripts/start-dev.ts` to launch a single process; understand kill/restart semantics and worker supervision for watchers.

## 5. Tooling & Release Process Impacts

- TypeScript build: Vite currently chains `tsc -b`; confirm Bun bundler pipeline still runs type-checking or decide on parallel step.
- Testing: ensure `bun test` and Playwright commands operate against the new dev server endpoints and bundler outputs.
- CI pipelines: adjust `bun run build` and `bun run validate` scripts to account for Bun bundler usage and artifact paths.
- Documentation updates (README, dev docs) for new commands, env variables, and debugging workflows.

## 6. Open Questions / Next Research Steps

1. What is the minimum Bun version that provides the bundler/HMR features we need, and does it align with current `bun` constraints across the repo?
2. Can Bun generate service workers and precache manifests comparable to `vite-plugin-pwa`, or do we need a custom build step (perhaps using Workbox CLI)?
3. How will we replicate TanStack Router file-based route generation without Vite? Does the router offer a standalone generator we can invoke under Bun?
4. Does Bun support aliasing modules to `false` (used to block backend imports), or do we need a different guard (lint rule, build-time checks)?
5. How will we produce compression artifacts and bundle analysis reports post-build?
6. What changes are required in deployment infrastructure (e.g., expecting `dist` folders) once the server serves bundles directly from memory or a new path?
7. Do we need to rework global styles or CSS modules to accommodate differences in Bun's CSS handling?
8. How will hot reloading behave for shared workspace packages (`@promptliano/ui`, `@promptliano/brand-kit`) when consumed by the client/website through the Bun bundler?

Collecting answers to these questions will clarify the feasibility path for replacing Vite with Bun across the frontend codebase and unifying the runtime behind the Bun server.
