// This file is auto-generated by @hey-api/openapi-ts

export type Chat = {
    id: string;
    title: string;
    createdAt: string;
    updatedAt: string;
};

export type ChatListResponse = {
    success: true;
    data: Array<Chat>;
};

export type ApiErrorResponse = {
    success: false;
    error: {
        message: string;
        code?: string;
        details?: {};
    };
};

export type ChatResponse = {
    success: true;
    data: Chat;
};

export type CreateChatRequestBody = {
    title: string;
    /**
     * Copy messages from currentChatId if true
     */
    copyExisting?: boolean;
    currentChatId?: string;
};

export type ChatMessage = {
    /**
     * Message ID
     */
    id: string;
    /**
     * Parent Chat ID
     */
    chatId: string;
    /**
     * Role of the message sender
     */
    role: 'system' | 'user' | 'assistant' | 'tool' | 'function' | 'data';
    /**
     * Message content
     */
    content: string;
    /**
     * Creation timestamp (ISO 8601)
     */
    createdAt: string;
};

export type MessageListResponse = {
    success: true;
    data: Array<ChatMessage>;
};

export type UnifiedModel = {
    /**
     * Model identifier
     */
    id: string;
    /**
     * User-friendly model name
     */
    name: string;
    /**
     * Provider ID
     */
    provider: string;
    /**
     * Context window size
     */
    context_length?: number;
};

export type ModelsListResponse = {
    success: true;
    data: Array<UnifiedModel>;
};

export type AiMessage = {
    role: 'system' | 'user' | 'assistant' | 'tool' | 'function' | 'data';
    content: string;
    id?: string;
    name?: string;
    tool_call_id?: string;
};

/**
 * Optional parameters for the AI model.
 */
export type AiSdkOptions = {
    /**
     * Model ID to use
     */
    model?: string;
    temperature?: number;
    maxTokens?: number;
    topP?: number;
    frequencyPenalty?: number;
    presencePenalty?: number;
    topK?: number;
    /**
     * Provider-specific response format options
     */
    response_format?: unknown;
    /**
     * Mode for structured output (if supported)
     */
    structuredOutputMode?: 'auto' | 'tool' | 'json';
    /**
     * Name for structured output schema
     */
    schemaName?: string;
    /**
     * Description for structured output schema
     */
    schemaDescription?: string;
    /**
     * Strategy for structured output generation
     */
    outputStrategy?: 'object' | 'array' | 'enum' | 'no-schema';
};

export type AiChatRequestBody = {
    /**
     * Array of messages forming the conversation history.
     */
    messages: Array<AiMessage>;
    /**
     * The ID of the chat session this request belongs to.
     */
    chatId: string;
    /**
     * The AI provider to use (e.g., openai, anthropic) or a custom identifier.
     */
    provider?: ('openai' | 'openrouter' | 'lmstudio' | 'ollama' | 'xai' | 'google_gemini' | 'anthropic' | 'groq' | 'together') | string;
    options?: AiSdkOptions;
    /**
     * Temporary client-side ID for optimistic updates.
     */
    tempId?: string;
    /**
     * Optional system message to guide the AI.
     */
    systemMessage?: string;
    /**
     * Optional Zod schema (or JSON schema representation) for structured output.
     */
    schema?: unknown;
    /**
     * Optional array of enum values for specific structured output strategies.
     */
    enumValues?: Array<string>;
};

export type ForkChatRequestBody = {
    /**
     * Optional list of message IDs to exclude from the fork
     */
    excludedMessageIds?: Array<string>;
};

export type ForkChatFromMessageRequestBody = {
    /**
     * Optional list of message IDs to exclude from the fork
     */
    excludedMessageIds?: Array<string>;
};

export type OperationSuccessResponse = {
    success: true;
    message: string;
};

export type UpdateChatRequestBody = {
    title: string;
};

export type StructuredOutputResponse = {
    success: true;
    data?: unknown;
};

export type StructuredOutputRequest = {
    /**
     * Type of structured output to generate
     */
    outputType: string;
    /**
     * User prompt for generating the output
     */
    userMessage: string;
    /**
     * Optional system prompt
     */
    systemMessage?: string;
    /**
     * Optional model to use
     */
    model?: string;
    /**
     * Optional temperature parameter
     */
    temperature?: number;
    /**
     * Optional chat ID for tracking
     */
    chatId?: string;
};

export type Ticket = {
    /**
     * Unique ticket identifier
     */
    id: string;
    /**
     * Project this ticket belongs to
     */
    projectId: string;
    /**
     * Ticket title
     */
    title: string;
    /**
     * Ticket description
     */
    overview: string;
    /**
     * Current ticket status
     */
    status: 'open' | 'in_progress' | 'closed';
    /**
     * Ticket priority
     */
    priority: 'low' | 'normal' | 'high';
    /**
     * JSON string of suggested file IDs
     */
    suggestedFileIds: string;
    /**
     * Creation timestamp
     */
    createdAt: string;
    /**
     * Last update timestamp
     */
    updatedAt: string;
};

export type TicketResponse = {
    success: true;
    ticket: Ticket;
};

export type CreateTicketBody = {
    projectId: string;
    title: string;
    overview?: string;
    status?: 'open' | 'in_progress' | 'closed';
    priority?: 'low' | 'normal' | 'high';
    suggestedFileIds?: Array<string>;
};

export type UpdateTicketBody = {
    title?: string;
    overview?: string;
    status?: 'open' | 'in_progress' | 'closed';
    priority?: 'low' | 'normal' | 'high';
    suggestedFileIds?: Array<string>;
};

export type LinkedFilesResponse = {
    success: true;
    linkedFiles: Array<{
        ticketId: string;
        fileId: string;
    }>;
};

export type LinkFilesBody = {
    fileIds: Array<string>;
};

export type SuggestedFilesResponse = {
    success: true;
    recommendedFileIds: Array<string>;
    combinedSummaries?: string;
    message?: string;
};

export type SuggestFilesBody = {
    /**
     * Optional additional context for file suggestions
     */
    extraUserInput?: string;
};

export type SuggestedTasksResponse = {
    success: true;
    suggestedTasks: Array<string>;
};

export type SuggestTasksBody = {
    userContext?: string;
};

export type TicketListResponse = {
    success: true;
    tickets: Array<Ticket>;
};

export type TicketWithTaskCount = {
    ticket: Ticket;
    taskCount: number;
    completedTaskCount: number;
};

export type TicketWithTaskCountListResponse = {
    success: true;
    ticketsWithCount: Array<TicketWithTaskCount>;
};

export type Task = {
    /**
     * Unique task identifier
     */
    id: string;
    /**
     * Ticket this task belongs to
     */
    ticketId: string;
    /**
     * Task content/description
     */
    content: string;
    /**
     * Whether the task is completed
     */
    done: boolean;
    /**
     * Task order within the ticket
     */
    orderIndex: number;
    /**
     * Creation timestamp
     */
    createdAt: string;
    /**
     * Last update timestamp
     */
    updatedAt: string;
};

export type TicketWithTasks = {
    ticket: Ticket;
    tasks: Array<Task>;
};

export type TicketWithTasksListResponse = {
    success: true;
    ticketsWithTasks: Array<TicketWithTasks>;
};

export type TaskResponse = {
    success: true;
    task: Task;
};

export type CreateTaskBody = {
    content: string;
};

export type TaskListResponse = {
    success: true;
    tasks: Array<Task>;
};

export type UpdateTaskBody = {
    content?: string;
    done?: boolean;
};

export type ReorderTasksBody = {
    tasks: Array<{
        taskId: string;
        orderIndex: number;
    }>;
};

export type BulkTasksResponse = {
    success: true;
    tasks: {
        [key: string]: Array<Task>;
    };
};

export type Project = {
    id: string;
    name: string;
    description: string;
    path: string;
    createdAt: string;
    updatedAt: string;
};

export type ProjectResponse = {
    success: true;
    data: Project;
};

export type ProjectResponseMultiStatus = ProjectResponse & {
    warning?: string;
    error?: string;
};

export type CreateProjectRequestBody = {
    name: string;
    path: string;
    description?: string;
};

export type ProjectListResponse = {
    success: true;
    data: Array<Project>;
};

export type UpdateProjectRequestBody = {
    name?: string;
    path?: string;
    description?: string;
};

export type ProjectFile = {
    id: string;
    projectId: string;
    name: string;
    path: string;
    extension: string;
    size: number;
    content: string;
    summary: string;
    summaryLastUpdatedAt: string;
    meta: string;
    checksum: string;
    createdAt: string;
    updatedAt: string;
};

export type FileListResponse = {
    success: true;
    data: Array<ProjectFile>;
};

export type FileSummaryListResponse = {
    success: true;
    data: Array<ProjectFile>;
};

export type SummarizeFilesResponse = {
    success: true;
    included: number;
    skipped: number;
    message: string;
};

export type SummarizeFilesRequestBody = {
    fileIds: Array<string>;
    /**
     * Force re-summarization even if summary exists
     */
    force?: boolean;
};

export type RemoveSummariesResponse = {
    success: true;
    removedCount: number;
    message: string;
};

export type RemoveSummariesRequestBody = {
    fileIds: Array<string>;
};

export type ProjectSummaryResponse = {
    success: true;
    summary: string;
};

export type SuggestFilesResponse = {
    success: true;
    recommendedFileIds: Array<string>;
};

export type SuggestFilesRequestBody = {
    userInput: string;
};

export type ProviderKey = {
    /**
     * Provider Key ID
     */
    id: string;
    /**
     * AI Provider identifier (e.g., openai, anthropic)
     */
    provider: string;
    /**
     * The actual API Key (handle with care)
     */
    key: string;
    /**
     * Creation timestamp (ISO 8601)
     */
    createdAt: string;
    /**
     * Last update timestamp (ISO 8601)
     */
    updatedAt: string;
};

export type ProviderKeyWithSecret = ProviderKey & {
    [key: string]: unknown;
};

export type ProviderKeyResponse = {
    success: true;
    data: ProviderKeyWithSecret;
};

export type CreateProviderKeyRequestBody = {
    provider: string;
    key: string;
};

export type ProviderKeyListResponse = {
    success: true;
    data: Array<ProviderKey>;
};

export type UpdateProviderKeyRequestBody = {
    provider?: string;
    key?: string;
};

/**
 * Selected application color theme.
 */
export type Theme = 'light' | 'dark';

/**
 * Application-wide settings.
 */
export type AppSettings = {
    /**
     * Application display language code.
     */
    language?: string;
    theme?: Theme;
    /**
     * Name of the code syntax highlighting theme used in light mode.
     */
    codeThemeLight?: string;
    /**
     * Name of the code syntax highlighting theme used in dark mode.
     */
    codeThemeDark?: string;
    /**
     * Base URL for the Ollama server instance.
     */
    ollamaGlobalUrl?: string;
    /**
     * Base URL for the LM Studio local inference server.
     */
    lmStudioGlobalUrl?: string;
    /**
     * Glob patterns for files/folders to ignore during automatic summarization.
     */
    summarizationIgnorePatterns?: Array<string>;
    /**
     * Glob patterns for files/folders to explicitly include in summarization (if ignore patterns also match).
     */
    summarizationAllowPatterns?: Array<string>;
    /**
     * List of project UUIDs for which automatic summarization is enabled.
     */
    summarizationEnabledProjectIds?: Array<string>;
    /**
     * Whether pressing Spacebar accepts the current autocomplete suggestion.
     */
    useSpacebarToSelectAutocomplete?: boolean;
    /**
     * Whether to hide tooltips that provide general information or tips.
     */
    hideInformationalTooltips?: boolean;
    /**
     * Whether the chat view should automatically scroll to the bottom on new messages.
     */
    autoScrollEnabled?: boolean;
    /**
     * Default AI provider to use for chat.
     */
    provider?: 'openai' | 'openrouter' | 'lmstudio' | 'ollama' | 'xai' | 'google_gemini' | 'anthropic' | 'groq' | 'together';
    /**
     * Default AI model name to use for chat.
     */
    model?: string;
    /**
     * Controls randomness. Lower values make the model more deterministic.
     */
    temperature?: number;
    /**
     * Maximum number of tokens to generate in the chat completion.
     */
    max_tokens?: number;
    /**
     * Nucleus sampling parameter. Considers tokens with top_p probability mass.
     */
    top_p?: number;
    /**
     * Penalizes new tokens based on their frequency in the text so far.
     */
    frequency_penalty?: number;
    /**
     * Penalizes new tokens based on whether they appear in the text so far.
     */
    presence_penalty?: number;
    /**
     * Whether to stream back partial progress.
     */
    stream?: boolean;
};

/**
 * Represents the state of a single project tab, including selections, searches, and configurations specific to that tab.
 */
export type ProjectTabState = {
    /**
     * UUID of the currently selected project within this tab, or null.
     */
    selectedProjectId?: string;
    /**
     * UUID of the project whose settings are being edited within this tab, or null.
     */
    editProjectId?: string;
    /**
     * Whether the prompt selection/creation dialog is open in this tab.
     */
    promptDialogOpen?: boolean;
    /**
     * UUID of the prompt being edited in this tab, or null.
     */
    editPromptId?: string;
    /**
     * Current search query for files within this project tab.
     */
    fileSearch?: string;
    /**
     * Array of file UUIDs currently selected in this tab.
     */
    selectedFiles?: Array<string>;
    /**
     * Array of prompt UUIDs currently selected in this tab.
     */
    selectedPrompts?: Array<string>;
    /**
     * The current user-entered text in the main prompt input for this tab.
     */
    userPrompt?: string;
    /**
     * Flag indicating if file search should search within file content.
     */
    searchByContent?: boolean;
    /**
     * User-defined display name for this project tab.
     */
    displayName?: string;
    /**
     * Context limit (in tokens) specifically configured for this project tab, overriding global settings if set.
     */
    contextLimit?: number;
    /**
     * Whether to attempt resolving imports to include related file context.
     */
    resolveImports?: boolean;
    /**
     * The preferred editor to open files with from this tab.
     */
    preferredEditor?: 'vscode' | 'cursor' | 'webstorm';
    /**
     * Array of file UUIDs suggested by the AI for the current context.
     */
    suggestedFileIds?: Array<string>;
    /**
     * A record of user-defined file groups (bookmarks), mapping group names to arrays of file UUIDs.
     */
    bookmarkedFileGroups?: {
        [key: string]: Array<string>;
    };
    /**
     * Current search query for tickets.
     */
    ticketSearch?: string;
    /**
     * Sorting criteria for the ticket list.
     */
    ticketSort?: 'created_desc' | 'created_asc' | 'status' | 'priority';
    /**
     * Filter criteria for ticket status.
     */
    ticketStatusFilter?: 'all' | 'open' | 'in_progress' | 'closed';
    /**
     * UUID of the currently selected ticket, or null.
     */
    ticketId?: string;
    /**
     * Numerical sort order for arranging project tabs.
     */
    sortOrder?: number;
};

/**
 * State of all open project tabs, keyed by tab ID.
 */
export type ProjectTabsStateRecord = {
    [key: string]: ProjectTabState;
};

/**
 * Settings defining how a chat is linked to a project tab and what context is shared.
 */
export type ChatLinkSetting = {
    /**
     * Whether currently selected files from the linked project tab should be included as context.
     */
    includeSelectedFiles?: boolean;
    /**
     * Whether selected prompts from the linked project tab should be included.
     */
    includePrompts?: boolean;
    /**
     * Whether the user prompt input from the linked project tab should be included.
     */
    includeUserPrompt?: boolean;
    /**
     * The UUID of the project tab this chat is linked to, or null if not linked.
     */
    linkedProjectTabId?: string;
};

/**
 * Link settings specific to each chat session.
 */
export type ChatLinkSettingsMap = {
    [key: string]: ChatLinkSetting;
};

/**
 * Represents the entire persistent application state.
 */
export type GlobalState = {
    settings: AppSettings;
    projectTabs: ProjectTabsStateRecord;
    /**
     * The UUID of the currently active project tab, or null if none is active.
     */
    projectActiveTabId?: string;
    /**
     * The UUID of the currently active chat session, or null.
     */
    activeChatId?: string;
    chatLinkSettings?: ChatLinkSettingsMap;
};

/**
 * Standard success response containing the complete current global application state.
 */
export type StateResponse = {
    success: true;
    data: GlobalState;
};

/**
 * A partial AppSettings object containing the keys and new values to update.
 */
export type UpdateSettingsBody = {
    /**
     * Application display language code.
     */
    language?: string;
    theme?: Theme;
    /**
     * Name of the code syntax highlighting theme used in light mode.
     */
    codeThemeLight?: string;
    /**
     * Name of the code syntax highlighting theme used in dark mode.
     */
    codeThemeDark?: string;
    /**
     * Base URL for the Ollama server instance.
     */
    ollamaGlobalUrl?: string;
    /**
     * Base URL for the LM Studio local inference server.
     */
    lmStudioGlobalUrl?: string;
    /**
     * Glob patterns for files/folders to ignore during automatic summarization.
     */
    summarizationIgnorePatterns?: Array<string>;
    /**
     * Glob patterns for files/folders to explicitly include in summarization (if ignore patterns also match).
     */
    summarizationAllowPatterns?: Array<string>;
    /**
     * List of project UUIDs for which automatic summarization is enabled.
     */
    summarizationEnabledProjectIds?: Array<string>;
    /**
     * Whether pressing Spacebar accepts the current autocomplete suggestion.
     */
    useSpacebarToSelectAutocomplete?: boolean;
    /**
     * Whether to hide tooltips that provide general information or tips.
     */
    hideInformationalTooltips?: boolean;
    /**
     * Whether the chat view should automatically scroll to the bottom on new messages.
     */
    autoScrollEnabled?: boolean;
    /**
     * Default AI provider to use for chat.
     */
    provider?: 'openai' | 'openrouter' | 'lmstudio' | 'ollama' | 'xai' | 'google_gemini' | 'anthropic' | 'groq' | 'together';
    /**
     * Default AI model name to use for chat.
     */
    model?: string;
    /**
     * Controls randomness. Lower values make the model more deterministic.
     */
    temperature?: number;
    /**
     * Maximum number of tokens to generate in the chat completion.
     */
    max_tokens?: number;
    /**
     * Nucleus sampling parameter. Considers tokens with top_p probability mass.
     */
    top_p?: number;
    /**
     * Penalizes new tokens based on their frequency in the text so far.
     */
    frequency_penalty?: number;
    /**
     * Penalizes new tokens based on whether they appear in the text so far.
     */
    presence_penalty?: number;
    /**
     * Whether to stream back partial progress.
     */
    stream?: boolean;
};

export type SetActiveProjectTabBody = {
    /**
     * The UUID of the project tab to set as active, or null.
     */
    tabId: string;
};

export type SetActiveChatBody = {
    /**
     * The UUID of the chat session to set as active, or null.
     */
    chatId: string;
};

export type CreateProjectTabResponse = {
    success: true;
    /**
     * The UUID of the newly created project tab.
     */
    tabId: string;
    data: GlobalState;
};

/**
 * Initial data for creating a new project tab. A unique ID will be generated.
 */
export type CreateProjectTabBody = {
    /**
     * UUID of the currently selected project within this tab, or null.
     */
    selectedProjectId?: string;
    /**
     * UUID of the project whose settings are being edited within this tab, or null.
     */
    editProjectId?: string;
    /**
     * Whether the prompt selection/creation dialog is open in this tab.
     */
    promptDialogOpen?: boolean;
    /**
     * UUID of the prompt being edited in this tab, or null.
     */
    editPromptId?: string;
    /**
     * Current search query for files within this project tab.
     */
    fileSearch?: string;
    /**
     * Array of file UUIDs currently selected in this tab.
     */
    selectedFiles?: Array<string>;
    /**
     * Array of prompt UUIDs currently selected in this tab.
     */
    selectedPrompts?: Array<string>;
    /**
     * The current user-entered text in the main prompt input for this tab.
     */
    userPrompt?: string;
    /**
     * Flag indicating if file search should search within file content.
     */
    searchByContent?: boolean;
    /**
     * Optional initial display name for the tab.
     */
    displayName?: string;
    /**
     * Context limit (in tokens) specifically configured for this project tab, overriding global settings if set.
     */
    contextLimit?: number;
    /**
     * Whether to attempt resolving imports to include related file context.
     */
    resolveImports?: boolean;
    /**
     * The preferred editor to open files with from this tab.
     */
    preferredEditor?: 'vscode' | 'cursor' | 'webstorm';
    /**
     * Array of file UUIDs suggested by the AI for the current context.
     */
    suggestedFileIds?: Array<string>;
    /**
     * A record of user-defined file groups (bookmarks), mapping group names to arrays of file UUIDs.
     */
    bookmarkedFileGroups?: {
        [key: string]: Array<string>;
    };
    /**
     * Current search query for tickets.
     */
    ticketSearch?: string;
    /**
     * Sorting criteria for the ticket list.
     */
    ticketSort?: 'created_desc' | 'created_asc' | 'status' | 'priority';
    /**
     * Filter criteria for ticket status.
     */
    ticketStatusFilter?: 'all' | 'open' | 'in_progress' | 'closed';
    /**
     * UUID of the currently selected ticket, or null.
     */
    ticketId?: string;
    /**
     * The required UUID of the project this tab belongs to.
     */
    projectId: string;
};

/**
 * A partial ProjectTabState object containing the fields to update for the specified tab.
 */
export type UpdateSingleProjectTabBody = {
    /**
     * UUID of the currently selected project within this tab, or null.
     */
    selectedProjectId?: string;
    /**
     * UUID of the project whose settings are being edited within this tab, or null.
     */
    editProjectId?: string;
    /**
     * Whether the prompt selection/creation dialog is open in this tab.
     */
    promptDialogOpen?: boolean;
    /**
     * UUID of the prompt being edited in this tab, or null.
     */
    editPromptId?: string;
    /**
     * Current search query for files within this project tab.
     */
    fileSearch?: string;
    /**
     * Array of file UUIDs currently selected in this tab.
     */
    selectedFiles?: Array<string>;
    /**
     * Array of prompt UUIDs currently selected in this tab.
     */
    selectedPrompts?: Array<string>;
    /**
     * The current user-entered text in the main prompt input for this tab.
     */
    userPrompt?: string;
    /**
     * Flag indicating if file search should search within file content.
     */
    searchByContent?: boolean;
    /**
     * User-defined display name for this project tab.
     */
    displayName?: string;
    /**
     * Context limit (in tokens) specifically configured for this project tab, overriding global settings if set.
     */
    contextLimit?: number;
    /**
     * Whether to attempt resolving imports to include related file context.
     */
    resolveImports?: boolean;
    /**
     * The preferred editor to open files with from this tab.
     */
    preferredEditor?: 'vscode' | 'cursor' | 'webstorm';
    /**
     * Array of file UUIDs suggested by the AI for the current context.
     */
    suggestedFileIds?: Array<string>;
    /**
     * A record of user-defined file groups (bookmarks), mapping group names to arrays of file UUIDs.
     */
    bookmarkedFileGroups?: {
        [key: string]: Array<string>;
    };
    /**
     * Current search query for tickets.
     */
    ticketSearch?: string;
    /**
     * Sorting criteria for the ticket list.
     */
    ticketSort?: 'created_desc' | 'created_asc' | 'status' | 'priority';
    /**
     * Filter criteria for ticket status.
     */
    ticketStatusFilter?: 'all' | 'open' | 'in_progress' | 'closed';
    /**
     * UUID of the currently selected ticket, or null.
     */
    ticketId?: string;
    /**
     * Numerical sort order for arranging project tabs.
     */
    sortOrder?: number;
};

/**
 * The complete record of project tabs (UUID -> ProjectTabState) to replace the existing ones.
 */
export type ReplaceProjectTabsBody = {
    [key: string]: ProjectTabState;
};

/**
 * The complete GlobalState object that will replace the current application state.
 */
export type ReplaceStateBody = {
    settings: AppSettings;
    projectTabs: ProjectTabsStateRecord;
    /**
     * The UUID of the currently active project tab, or null if none is active.
     */
    projectActiveTabId?: string;
    /**
     * The UUID of the currently active chat session, or null.
     */
    activeChatId?: string;
    chatLinkSettings?: ChatLinkSettingsMap;
};

/**
 * Specifies a single top-level key and its new value for performing a partial update on the global state.
 */
export type UpdateStatePartialBody = {
    /**
     * The top-level key within the GlobalState object to update (e.g., "settings", "projectActiveTabId").
     */
    key: string;
    /**
     * The new value for the specified key. The type must match the expected type for that key in the GlobalState schema.
     */
    value?: unknown;
};

export type EnvironmentInfo = {
    NODE_ENV: string;
    BUN_ENV: string;
    SERVER_PORT: string;
};

export type ServerInfo = {
    version: string;
    bunVersion: string;
    platform: string;
    arch: string;
    memoryUsage: {
        rss: number;
        heapTotal: number;
        heapUsed: number;
        external: number;
        arrayBuffers: number;
    };
    uptime: number;
};

export type DatabaseStats = {
    chats: {
        count: number;
    };
    chat_messages: {
        count: number;
    };
    projects: {
        count: number;
    };
    files: {
        count: number;
    };
    prompts: {
        count: number;
    };
    prompt_projects: {
        count: number;
    };
    provider_keys: {
        count: number;
    };
    tickets: {
        count: number;
    };
    ticket_files: {
        count: number;
    };
    ticket_tasks: {
        count: number;
    };
    file_changes: {
        count: number;
    };
};

export type EnvInfoResponse = {
    success: true;
    environment: EnvironmentInfo;
    serverInfo: ServerInfo;
    databaseStats: DatabaseStats;
};

export type SystemStatusResponse = {
    success: true;
    status: string;
    checks: {
        api: string;
        timestamp: string;
    };
};

export type FileChangeResult = {
    id: number;
    filePath: string;
    originalContent: string;
    suggestedContent: string;
    diff: string;
    prompt: string;
    status: string;
    createdAt: string;
};

export type FileChangeResponse = {
    success: true;
    result: FileChangeResult;
};

export type GenerateChangeBody = {
    /**
     * Path to the file to modify
     */
    filePath: string;
    /**
     * Instruction for the AI to follow
     */
    prompt: string;
};

export type FileChangeDetails = {
    id: number;
    filePath: string;
    originalContent: string;
    suggestedContent: string;
    diff: string;
    prompt: string;
    status: string;
    createdAt: string;
};

export type FileChangeDetailsResponse = {
    success: true;
    fileChange: FileChangeDetails;
};

export type ConfirmChangeResult = {
    status: string;
    message: string;
};

export type ConfirmChangeResponse = {
    success: true;
    result: ConfirmChangeResult;
};

export type Prompt = {
    /**
     * Prompt ID
     */
    id: string;
    /**
     * Prompt name
     */
    name: string;
    /**
     * Prompt content template
     */
    content: string;
    /**
     * Optional Project ID this prompt is linked to (contextual)
     */
    projectId?: string;
    /**
     * Creation timestamp (ISO 8601)
     */
    createdAt: string;
    /**
     * Last update timestamp (ISO 8601)
     */
    updatedAt: string;
};

export type PromptResponse = {
    success: true;
    data: Prompt;
};

export type CreatePromptRequestBody = {
    /**
     * Optional Project ID to link the prompt to upon creation
     */
    projectId?: string;
    name: string;
    content: string;
};

export type PromptListResponse = {
    success: true;
    data: Array<Prompt>;
};

export type UpdatePromptRequestBody = {
    name?: string;
    content?: string;
};

export type OptimizePromptResponse = {
    /**
     * Indicates successful optimization
     */
    success: true;
    data: {
        /**
         * The optimized prompt generated by the service.
         */
        optimizedPrompt: string;
    };
};

export type OptimizePromptRequest = {
    /**
     * The user's initial prompt or context to be optimized.
     */
    userContext: string;
};

export type GetChatsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/chats';
};

export type GetChatsErrors = {
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetChatsError = GetChatsErrors[keyof GetChatsErrors];

export type GetChatsResponses = {
    /**
     * Successfully retrieved all chats
     */
    200: ChatListResponse;
};

export type GetChatsResponse = GetChatsResponses[keyof GetChatsResponses];

export type PostChatsData = {
    /**
     * Data for the new chat session
     */
    body: CreateChatRequestBody;
    path?: never;
    query?: never;
    url: '/chats';
};

export type PostChatsErrors = {
    /**
     * Referenced chat not found
     */
    404: ApiErrorResponse;
    /**
     * Validation error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostChatsError = PostChatsErrors[keyof PostChatsErrors];

export type PostChatsResponses = {
    /**
     * Chat created successfully
     */
    201: ChatResponse;
};

export type PostChatsResponse = PostChatsResponses[keyof PostChatsResponses];

export type GetChatsByChatIdMessagesData = {
    body?: never;
    path: {
        /**
         * The ID of the chat to retrieve messages for
         */
        chatId: string;
    };
    query?: never;
    url: '/chats/{chatId}/messages';
};

export type GetChatsByChatIdMessagesErrors = {
    /**
     * Chat not found
     */
    404: ApiErrorResponse;
    /**
     * Validation error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetChatsByChatIdMessagesError = GetChatsByChatIdMessagesErrors[keyof GetChatsByChatIdMessagesErrors];

export type GetChatsByChatIdMessagesResponses = {
    /**
     * Successfully retrieved messages
     */
    200: MessageListResponse;
};

export type GetChatsByChatIdMessagesResponse = GetChatsByChatIdMessagesResponses[keyof GetChatsByChatIdMessagesResponses];

export type GetModelsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The provider to filter models by
         */
        provider: string;
    };
    url: '/models';
};

export type GetModelsErrors = {
    /**
     * Invalid provider or configuration error
     */
    400: ApiErrorResponse;
    /**
     * Validation error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetModelsError = GetModelsErrors[keyof GetModelsErrors];

export type GetModelsResponses = {
    /**
     * Successfully retrieved model list
     */
    200: ModelsListResponse;
};

export type GetModelsResponse = GetModelsResponses[keyof GetModelsResponses];

export type PostAiChatData = {
    /**
     * Chat context and message to send to the AI
     */
    body: AiChatRequestBody;
    path?: never;
    query?: never;
    url: '/ai/chat';
};

export type PostAiChatErrors = {
    /**
     * Invalid input or missing user message
     */
    400: ApiErrorResponse;
    /**
     * Validation error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error or AI provider error
     */
    500: ApiErrorResponse;
};

export type PostAiChatError = PostAiChatErrors[keyof PostAiChatErrors];

export type PostAiChatResponses = {
    /**
     * Streamed AI response chunks
     */
    200: string;
};

export type PostAiChatResponse = PostAiChatResponses[keyof PostAiChatResponses];

export type PostChatsByChatIdForkData = {
    /**
     * Optional message IDs to exclude from the fork
     */
    body: ForkChatRequestBody;
    path: {
        /**
         * The ID of the chat to fork
         */
        chatId: string;
    };
    query?: never;
    url: '/chats/{chatId}/fork';
};

export type PostChatsByChatIdForkErrors = {
    /**
     * Original chat not found
     */
    404: ApiErrorResponse;
    /**
     * Validation error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostChatsByChatIdForkError = PostChatsByChatIdForkErrors[keyof PostChatsByChatIdForkErrors];

export type PostChatsByChatIdForkResponses = {
    /**
     * Chat forked successfully
     */
    201: ChatResponse;
};

export type PostChatsByChatIdForkResponse = PostChatsByChatIdForkResponses[keyof PostChatsByChatIdForkResponses];

export type PostChatsByChatIdForkByMessageIdData = {
    /**
     * Optional message IDs to exclude from the fork
     */
    body: ForkChatFromMessageRequestBody;
    path: {
        /**
         * The ID of the chat to fork
         */
        chatId: string;
        /**
         * The ID of the message to fork from
         */
        messageId: string;
    };
    query?: never;
    url: '/chats/{chatId}/fork/{messageId}';
};

export type PostChatsByChatIdForkByMessageIdErrors = {
    /**
     * Original chat or message not found
     */
    404: ApiErrorResponse;
    /**
     * Validation error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostChatsByChatIdForkByMessageIdError = PostChatsByChatIdForkByMessageIdErrors[keyof PostChatsByChatIdForkByMessageIdErrors];

export type PostChatsByChatIdForkByMessageIdResponses = {
    /**
     * Chat forked successfully from message
     */
    201: ChatResponse;
};

export type PostChatsByChatIdForkByMessageIdResponse = PostChatsByChatIdForkByMessageIdResponses[keyof PostChatsByChatIdForkByMessageIdResponses];

export type DeleteMessagesByMessageIdData = {
    body?: never;
    path: {
        /**
         * The ID of the message to delete
         */
        messageId: string;
    };
    query?: never;
    url: '/messages/{messageId}';
};

export type DeleteMessagesByMessageIdErrors = {
    /**
     * Message not found
     */
    404: ApiErrorResponse;
    /**
     * Validation error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type DeleteMessagesByMessageIdError = DeleteMessagesByMessageIdErrors[keyof DeleteMessagesByMessageIdErrors];

export type DeleteMessagesByMessageIdResponses = {
    /**
     * Message deleted successfully
     */
    200: OperationSuccessResponse;
};

export type DeleteMessagesByMessageIdResponse = DeleteMessagesByMessageIdResponses[keyof DeleteMessagesByMessageIdResponses];

export type DeleteChatsByChatIdData = {
    body?: never;
    path: {
        /**
         * The ID of the chat to delete
         */
        chatId: string;
    };
    query?: never;
    url: '/chats/{chatId}';
};

export type DeleteChatsByChatIdErrors = {
    /**
     * Chat not found
     */
    404: ApiErrorResponse;
    /**
     * Validation error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type DeleteChatsByChatIdError = DeleteChatsByChatIdErrors[keyof DeleteChatsByChatIdErrors];

export type DeleteChatsByChatIdResponses = {
    /**
     * Chat deleted successfully
     */
    200: OperationSuccessResponse;
};

export type DeleteChatsByChatIdResponse = DeleteChatsByChatIdResponses[keyof DeleteChatsByChatIdResponses];

export type PatchChatsByChatIdData = {
    /**
     * Data to update for the chat
     */
    body: UpdateChatRequestBody;
    path: {
        /**
         * The ID of the chat to update
         */
        chatId: string;
    };
    query?: never;
    url: '/chats/{chatId}';
};

export type PatchChatsByChatIdErrors = {
    /**
     * Chat not found
     */
    404: ApiErrorResponse;
    /**
     * Validation error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PatchChatsByChatIdError = PatchChatsByChatIdErrors[keyof PatchChatsByChatIdErrors];

export type PatchChatsByChatIdResponses = {
    /**
     * Chat updated successfully
     */
    200: ChatResponse;
};

export type PatchChatsByChatIdResponse = PatchChatsByChatIdResponses[keyof PatchChatsByChatIdResponses];

export type PostApiStructuredOutputsData = {
    body?: StructuredOutputRequest;
    path?: never;
    query?: never;
    url: '/api/structured-outputs';
};

export type PostApiStructuredOutputsErrors = {
    /**
     * Invalid request or unsupported output type
     */
    400: ApiErrorResponse;
    /**
     * Error generating structured output
     */
    500: ApiErrorResponse;
};

export type PostApiStructuredOutputsError = PostApiStructuredOutputsErrors[keyof PostApiStructuredOutputsErrors];

export type PostApiStructuredOutputsResponses = {
    /**
     * Successfully generated structured output
     */
    200: StructuredOutputResponse;
};

export type PostApiStructuredOutputsResponse = PostApiStructuredOutputsResponses[keyof PostApiStructuredOutputsResponses];

export type PostApiTicketsData = {
    body?: CreateTicketBody;
    path?: never;
    query?: never;
    url: '/api/tickets';
};

export type PostApiTicketsErrors = {
    /**
     * Validation Error
     */
    400: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiTicketsError = PostApiTicketsErrors[keyof PostApiTicketsErrors];

export type PostApiTicketsResponses = {
    /**
     * Ticket created successfully
     */
    201: TicketResponse;
};

export type PostApiTicketsResponse = PostApiTicketsResponses[keyof PostApiTicketsResponses];

export type DeleteApiTicketsByTicketIdData = {
    body?: never;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}';
};

export type DeleteApiTicketsByTicketIdErrors = {
    /**
     * Ticket not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type DeleteApiTicketsByTicketIdError = DeleteApiTicketsByTicketIdErrors[keyof DeleteApiTicketsByTicketIdErrors];

export type DeleteApiTicketsByTicketIdResponses = {
    /**
     * Ticket deleted successfully
     */
    200: OperationSuccessResponse;
};

export type DeleteApiTicketsByTicketIdResponse = DeleteApiTicketsByTicketIdResponses[keyof DeleteApiTicketsByTicketIdResponses];

export type GetApiTicketsByTicketIdData = {
    body?: never;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}';
};

export type GetApiTicketsByTicketIdErrors = {
    /**
     * Ticket not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiTicketsByTicketIdError = GetApiTicketsByTicketIdErrors[keyof GetApiTicketsByTicketIdErrors];

export type GetApiTicketsByTicketIdResponses = {
    /**
     * Ticket retrieved successfully
     */
    200: TicketResponse;
};

export type GetApiTicketsByTicketIdResponse = GetApiTicketsByTicketIdResponses[keyof GetApiTicketsByTicketIdResponses];

export type PatchApiTicketsByTicketIdData = {
    body?: UpdateTicketBody;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}';
};

export type PatchApiTicketsByTicketIdErrors = {
    /**
     * Ticket not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PatchApiTicketsByTicketIdError = PatchApiTicketsByTicketIdErrors[keyof PatchApiTicketsByTicketIdErrors];

export type PatchApiTicketsByTicketIdResponses = {
    /**
     * Ticket updated successfully
     */
    200: TicketResponse;
};

export type PatchApiTicketsByTicketIdResponse = PatchApiTicketsByTicketIdResponses[keyof PatchApiTicketsByTicketIdResponses];

export type PostApiTicketsByTicketIdLinkFilesData = {
    body?: LinkFilesBody;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}/link-files';
};

export type PostApiTicketsByTicketIdLinkFilesErrors = {
    /**
     * Ticket not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiTicketsByTicketIdLinkFilesError = PostApiTicketsByTicketIdLinkFilesErrors[keyof PostApiTicketsByTicketIdLinkFilesErrors];

export type PostApiTicketsByTicketIdLinkFilesResponses = {
    /**
     * Files linked successfully
     */
    200: LinkedFilesResponse;
};

export type PostApiTicketsByTicketIdLinkFilesResponse = PostApiTicketsByTicketIdLinkFilesResponses[keyof PostApiTicketsByTicketIdLinkFilesResponses];

export type PostApiTicketsByTicketIdSuggestFilesData = {
    body?: SuggestFilesBody;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}/suggest-files';
};

export type PostApiTicketsByTicketIdSuggestFilesErrors = {
    /**
     * Ticket not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiTicketsByTicketIdSuggestFilesError = PostApiTicketsByTicketIdSuggestFilesErrors[keyof PostApiTicketsByTicketIdSuggestFilesErrors];

export type PostApiTicketsByTicketIdSuggestFilesResponses = {
    /**
     * Files suggested successfully
     */
    200: SuggestedFilesResponse;
};

export type PostApiTicketsByTicketIdSuggestFilesResponse = PostApiTicketsByTicketIdSuggestFilesResponses[keyof PostApiTicketsByTicketIdSuggestFilesResponses];

export type PostApiTicketsByTicketIdSuggestTasksData = {
    body?: SuggestTasksBody;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}/suggest-tasks';
};

export type PostApiTicketsByTicketIdSuggestTasksErrors = {
    /**
     * Ticket not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiTicketsByTicketIdSuggestTasksError = PostApiTicketsByTicketIdSuggestTasksErrors[keyof PostApiTicketsByTicketIdSuggestTasksErrors];

export type PostApiTicketsByTicketIdSuggestTasksResponses = {
    /**
     * Tasks suggested successfully
     */
    200: SuggestedTasksResponse;
};

export type PostApiTicketsByTicketIdSuggestTasksResponse = PostApiTicketsByTicketIdSuggestTasksResponses[keyof PostApiTicketsByTicketIdSuggestTasksResponses];

export type GetApiProjectsByProjectIdTicketsData = {
    body?: never;
    path: {
        /**
         * Project identifier
         */
        projectId: string;
    };
    query?: {
        /**
         * Filter tickets by status
         */
        status?: string;
    };
    url: '/api/projects/{projectId}/tickets';
};

export type GetApiProjectsByProjectIdTicketsErrors = {
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiProjectsByProjectIdTicketsError = GetApiProjectsByProjectIdTicketsErrors[keyof GetApiProjectsByProjectIdTicketsErrors];

export type GetApiProjectsByProjectIdTicketsResponses = {
    /**
     * Tickets listed successfully
     */
    200: TicketListResponse;
};

export type GetApiProjectsByProjectIdTicketsResponse = GetApiProjectsByProjectIdTicketsResponses[keyof GetApiProjectsByProjectIdTicketsResponses];

export type GetApiProjectsByProjectIdTicketsWithCountData = {
    body?: never;
    path: {
        /**
         * Project identifier
         */
        projectId: string;
    };
    query?: {
        /**
         * Filter tickets by status
         */
        status?: string;
    };
    url: '/api/projects/{projectId}/tickets-with-count';
};

export type GetApiProjectsByProjectIdTicketsWithCountErrors = {
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiProjectsByProjectIdTicketsWithCountError = GetApiProjectsByProjectIdTicketsWithCountErrors[keyof GetApiProjectsByProjectIdTicketsWithCountErrors];

export type GetApiProjectsByProjectIdTicketsWithCountResponses = {
    /**
     * Tickets with counts listed successfully
     */
    200: TicketWithTaskCountListResponse;
};

export type GetApiProjectsByProjectIdTicketsWithCountResponse = GetApiProjectsByProjectIdTicketsWithCountResponses[keyof GetApiProjectsByProjectIdTicketsWithCountResponses];

export type GetApiProjectsByProjectIdTicketsWithTasksData = {
    body?: never;
    path: {
        /**
         * Project identifier
         */
        projectId: string;
    };
    query?: {
        /**
         * Filter tickets by status
         */
        status?: string;
    };
    url: '/api/projects/{projectId}/tickets-with-tasks';
};

export type GetApiProjectsByProjectIdTicketsWithTasksErrors = {
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiProjectsByProjectIdTicketsWithTasksError = GetApiProjectsByProjectIdTicketsWithTasksErrors[keyof GetApiProjectsByProjectIdTicketsWithTasksErrors];

export type GetApiProjectsByProjectIdTicketsWithTasksResponses = {
    /**
     * Tickets with tasks listed successfully
     */
    200: TicketWithTasksListResponse;
};

export type GetApiProjectsByProjectIdTicketsWithTasksResponse = GetApiProjectsByProjectIdTicketsWithTasksResponses[keyof GetApiProjectsByProjectIdTicketsWithTasksResponses];

export type GetApiTicketsByTicketIdTasksData = {
    body?: never;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}/tasks';
};

export type GetApiTicketsByTicketIdTasksErrors = {
    /**
     * Ticket not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiTicketsByTicketIdTasksError = GetApiTicketsByTicketIdTasksErrors[keyof GetApiTicketsByTicketIdTasksErrors];

export type GetApiTicketsByTicketIdTasksResponses = {
    /**
     * Tasks retrieved successfully
     */
    200: TaskListResponse;
};

export type GetApiTicketsByTicketIdTasksResponse = GetApiTicketsByTicketIdTasksResponses[keyof GetApiTicketsByTicketIdTasksResponses];

export type PostApiTicketsByTicketIdTasksData = {
    body?: CreateTaskBody;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}/tasks';
};

export type PostApiTicketsByTicketIdTasksErrors = {
    /**
     * Ticket not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiTicketsByTicketIdTasksError = PostApiTicketsByTicketIdTasksErrors[keyof PostApiTicketsByTicketIdTasksErrors];

export type PostApiTicketsByTicketIdTasksResponses = {
    /**
     * Task created successfully
     */
    201: TaskResponse;
};

export type PostApiTicketsByTicketIdTasksResponse = PostApiTicketsByTicketIdTasksResponses[keyof PostApiTicketsByTicketIdTasksResponses];

export type DeleteApiTicketsByTicketIdTasksByTaskIdData = {
    body?: never;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
        /**
         * Task identifier
         */
        taskId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}/tasks/{taskId}';
};

export type DeleteApiTicketsByTicketIdTasksByTaskIdErrors = {
    /**
     * Task not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type DeleteApiTicketsByTicketIdTasksByTaskIdError = DeleteApiTicketsByTicketIdTasksByTaskIdErrors[keyof DeleteApiTicketsByTicketIdTasksByTaskIdErrors];

export type DeleteApiTicketsByTicketIdTasksByTaskIdResponses = {
    /**
     * Task deleted successfully
     */
    200: OperationSuccessResponse;
};

export type DeleteApiTicketsByTicketIdTasksByTaskIdResponse = DeleteApiTicketsByTicketIdTasksByTaskIdResponses[keyof DeleteApiTicketsByTicketIdTasksByTaskIdResponses];

export type PatchApiTicketsByTicketIdTasksByTaskIdData = {
    body?: UpdateTaskBody;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
        /**
         * Task identifier
         */
        taskId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}/tasks/{taskId}';
};

export type PatchApiTicketsByTicketIdTasksByTaskIdErrors = {
    /**
     * Task not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PatchApiTicketsByTicketIdTasksByTaskIdError = PatchApiTicketsByTicketIdTasksByTaskIdErrors[keyof PatchApiTicketsByTicketIdTasksByTaskIdErrors];

export type PatchApiTicketsByTicketIdTasksByTaskIdResponses = {
    /**
     * Task updated successfully
     */
    200: TaskResponse;
};

export type PatchApiTicketsByTicketIdTasksByTaskIdResponse = PatchApiTicketsByTicketIdTasksByTaskIdResponses[keyof PatchApiTicketsByTicketIdTasksByTaskIdResponses];

export type PatchApiTicketsByTicketIdTasksReorderData = {
    body?: ReorderTasksBody;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}/tasks/reorder';
};

export type PatchApiTicketsByTicketIdTasksReorderErrors = {
    /**
     * Ticket not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PatchApiTicketsByTicketIdTasksReorderError = PatchApiTicketsByTicketIdTasksReorderErrors[keyof PatchApiTicketsByTicketIdTasksReorderErrors];

export type PatchApiTicketsByTicketIdTasksReorderResponses = {
    /**
     * Tasks reordered successfully
     */
    200: TaskListResponse;
};

export type PatchApiTicketsByTicketIdTasksReorderResponse = PatchApiTicketsByTicketIdTasksReorderResponses[keyof PatchApiTicketsByTicketIdTasksReorderResponses];

export type PostApiTicketsByTicketIdAutoGenerateTasksData = {
    body?: never;
    path: {
        /**
         * Ticket identifier
         */
        ticketId: string;
    };
    query?: never;
    url: '/api/tickets/{ticketId}/auto-generate-tasks';
};

export type PostApiTicketsByTicketIdAutoGenerateTasksErrors = {
    /**
     * Ticket not found
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiTicketsByTicketIdAutoGenerateTasksError = PostApiTicketsByTicketIdAutoGenerateTasksErrors[keyof PostApiTicketsByTicketIdAutoGenerateTasksErrors];

export type PostApiTicketsByTicketIdAutoGenerateTasksResponses = {
    /**
     * Tasks generated successfully
     */
    200: TaskListResponse;
};

export type PostApiTicketsByTicketIdAutoGenerateTasksResponse = PostApiTicketsByTicketIdAutoGenerateTasksResponses[keyof PostApiTicketsByTicketIdAutoGenerateTasksResponses];

export type GetApiTicketsBulkTasksData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Comma-separated list of ticket IDs
         */
        ids: string;
    };
    url: '/api/tickets/bulk-tasks';
};

export type GetApiTicketsBulkTasksErrors = {
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiTicketsBulkTasksError = GetApiTicketsBulkTasksErrors[keyof GetApiTicketsBulkTasksErrors];

export type GetApiTicketsBulkTasksResponses = {
    /**
     * Tasks retrieved successfully
     */
    200: BulkTasksResponse;
};

export type GetApiTicketsBulkTasksResponse = GetApiTicketsBulkTasksResponses[keyof GetApiTicketsBulkTasksResponses];

export type GetApiProjectsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/projects';
};

export type GetApiProjectsErrors = {
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiProjectsError = GetApiProjectsErrors[keyof GetApiProjectsErrors];

export type GetApiProjectsResponses = {
    /**
     * Successfully retrieved all projects
     */
    200: ProjectListResponse;
};

export type GetApiProjectsResponse = GetApiProjectsResponses[keyof GetApiProjectsResponses];

export type PostApiProjectsData = {
    body?: CreateProjectRequestBody;
    path?: never;
    query?: never;
    url: '/api/projects';
};

export type PostApiProjectsErrors = {
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiProjectsError = PostApiProjectsErrors[keyof PostApiProjectsErrors];

export type PostApiProjectsResponses = {
    /**
     * Project created and initial sync started
     */
    201: ProjectResponse;
    /**
     * Project created, but post-creation steps encountered issues
     */
    207: ProjectResponseMultiStatus;
};

export type PostApiProjectsResponse = PostApiProjectsResponses[keyof PostApiProjectsResponses];

export type DeleteApiProjectsByProjectIdData = {
    body?: never;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}';
};

export type DeleteApiProjectsByProjectIdErrors = {
    /**
     * Project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type DeleteApiProjectsByProjectIdError = DeleteApiProjectsByProjectIdErrors[keyof DeleteApiProjectsByProjectIdErrors];

export type DeleteApiProjectsByProjectIdResponses = {
    /**
     * Project deleted successfully
     */
    200: OperationSuccessResponse;
};

export type DeleteApiProjectsByProjectIdResponse = DeleteApiProjectsByProjectIdResponses[keyof DeleteApiProjectsByProjectIdResponses];

export type GetApiProjectsByProjectIdData = {
    body?: never;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}';
};

export type GetApiProjectsByProjectIdErrors = {
    /**
     * Project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error (invalid projectId format)
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiProjectsByProjectIdError = GetApiProjectsByProjectIdErrors[keyof GetApiProjectsByProjectIdErrors];

export type GetApiProjectsByProjectIdResponses = {
    /**
     * Successfully retrieved project details
     */
    200: ProjectResponse;
};

export type GetApiProjectsByProjectIdResponse = GetApiProjectsByProjectIdResponses[keyof GetApiProjectsByProjectIdResponses];

export type PatchApiProjectsByProjectIdData = {
    body?: UpdateProjectRequestBody;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}';
};

export type PatchApiProjectsByProjectIdErrors = {
    /**
     * Project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PatchApiProjectsByProjectIdError = PatchApiProjectsByProjectIdErrors[keyof PatchApiProjectsByProjectIdErrors];

export type PatchApiProjectsByProjectIdResponses = {
    /**
     * Project updated successfully
     */
    200: ProjectResponse;
};

export type PatchApiProjectsByProjectIdResponse = PatchApiProjectsByProjectIdResponses[keyof PatchApiProjectsByProjectIdResponses];

export type PostApiProjectsByProjectIdSyncData = {
    body?: never;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}/sync';
};

export type PostApiProjectsByProjectIdSyncErrors = {
    /**
     * Project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error during sync
     */
    500: ApiErrorResponse;
};

export type PostApiProjectsByProjectIdSyncError = PostApiProjectsByProjectIdSyncErrors[keyof PostApiProjectsByProjectIdSyncErrors];

export type PostApiProjectsByProjectIdSyncResponses = {
    /**
     * Project sync initiated successfully
     */
    200: OperationSuccessResponse;
};

export type PostApiProjectsByProjectIdSyncResponse = PostApiProjectsByProjectIdSyncResponses[keyof PostApiProjectsByProjectIdSyncResponses];

export type GetApiProjectsByProjectIdFilesData = {
    body?: never;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}/files';
};

export type GetApiProjectsByProjectIdFilesErrors = {
    /**
     * Project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiProjectsByProjectIdFilesError = GetApiProjectsByProjectIdFilesErrors[keyof GetApiProjectsByProjectIdFilesErrors];

export type GetApiProjectsByProjectIdFilesResponses = {
    /**
     * Successfully retrieved project files
     */
    200: FileListResponse;
};

export type GetApiProjectsByProjectIdFilesResponse = GetApiProjectsByProjectIdFilesResponses[keyof GetApiProjectsByProjectIdFilesResponses];

export type PostApiProjectsByProjectIdRefreshData = {
    body?: never;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: {
        /**
         * Optional folder path to limit the refresh scope
         */
        folder?: string;
    };
    url: '/api/projects/{projectId}/refresh';
};

export type PostApiProjectsByProjectIdRefreshErrors = {
    /**
     * Project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error during refresh/sync
     */
    500: ApiErrorResponse;
};

export type PostApiProjectsByProjectIdRefreshError = PostApiProjectsByProjectIdRefreshErrors[keyof PostApiProjectsByProjectIdRefreshErrors];

export type PostApiProjectsByProjectIdRefreshResponses = {
    /**
     * Successfully refreshed project files
     */
    200: FileListResponse;
};

export type PostApiProjectsByProjectIdRefreshResponse = PostApiProjectsByProjectIdRefreshResponses[keyof PostApiProjectsByProjectIdRefreshResponses];

export type GetApiProjectsByProjectIdFileSummariesData = {
    body?: never;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: {
        /**
         * Optional comma-separated list of file IDs to retrieve summaries for
         */
        fileIds?: string;
    };
    url: '/api/projects/{projectId}/file-summaries';
};

export type GetApiProjectsByProjectIdFileSummariesErrors = {
    /**
     * Project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiProjectsByProjectIdFileSummariesError = GetApiProjectsByProjectIdFileSummariesErrors[keyof GetApiProjectsByProjectIdFileSummariesErrors];

export type GetApiProjectsByProjectIdFileSummariesResponses = {
    /**
     * Successfully retrieved file summaries
     */
    200: FileSummaryListResponse;
};

export type GetApiProjectsByProjectIdFileSummariesResponse = GetApiProjectsByProjectIdFileSummariesResponses[keyof GetApiProjectsByProjectIdFileSummariesResponses];

export type PostApiProjectsByProjectIdSummarizeData = {
    body?: SummarizeFilesRequestBody;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}/summarize';
};

export type PostApiProjectsByProjectIdSummarizeErrors = {
    /**
     * Project or some files not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error during summarization
     */
    500: ApiErrorResponse;
};

export type PostApiProjectsByProjectIdSummarizeError = PostApiProjectsByProjectIdSummarizeErrors[keyof PostApiProjectsByProjectIdSummarizeErrors];

export type PostApiProjectsByProjectIdSummarizeResponses = {
    /**
     * File summarization process completed
     */
    200: SummarizeFilesResponse;
};

export type PostApiProjectsByProjectIdSummarizeResponse = PostApiProjectsByProjectIdSummarizeResponses[keyof PostApiProjectsByProjectIdSummarizeResponses];

export type PostApiProjectsByProjectIdResummarizeAllData = {
    body?: never;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}/resummarize-all';
};

export type PostApiProjectsByProjectIdResummarizeAllErrors = {
    /**
     * Project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiProjectsByProjectIdResummarizeAllError = PostApiProjectsByProjectIdResummarizeAllErrors[keyof PostApiProjectsByProjectIdResummarizeAllErrors];

export type PostApiProjectsByProjectIdResummarizeAllResponses = {
    /**
     * Process to re-summarize all files started/completed
     */
    200: OperationSuccessResponse;
};

export type PostApiProjectsByProjectIdResummarizeAllResponse = PostApiProjectsByProjectIdResummarizeAllResponses[keyof PostApiProjectsByProjectIdResummarizeAllResponses];

export type PostApiProjectsByProjectIdRemoveSummariesData = {
    body?: RemoveSummariesRequestBody;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}/remove-summaries';
};

export type PostApiProjectsByProjectIdRemoveSummariesErrors = {
    /**
     * Project or some files not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiProjectsByProjectIdRemoveSummariesError = PostApiProjectsByProjectIdRemoveSummariesErrors[keyof PostApiProjectsByProjectIdRemoveSummariesErrors];

export type PostApiProjectsByProjectIdRemoveSummariesResponses = {
    /**
     * Summaries removed successfully
     */
    200: RemoveSummariesResponse;
};

export type PostApiProjectsByProjectIdRemoveSummariesResponse = PostApiProjectsByProjectIdRemoveSummariesResponses[keyof PostApiProjectsByProjectIdRemoveSummariesResponses];

export type GetApiProjectsByProjectIdSummaryData = {
    body?: never;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}/summary';
};

export type GetApiProjectsByProjectIdSummaryErrors = {
    /**
     * Project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiProjectsByProjectIdSummaryError = GetApiProjectsByProjectIdSummaryErrors[keyof GetApiProjectsByProjectIdSummaryErrors];

export type GetApiProjectsByProjectIdSummaryResponses = {
    /**
     * Successfully generated combined project summary
     */
    200: ProjectSummaryResponse;
};

export type GetApiProjectsByProjectIdSummaryResponse = GetApiProjectsByProjectIdSummaryResponses[keyof GetApiProjectsByProjectIdSummaryResponses];

export type PostApiProjectsByProjectIdSuggestFilesData = {
    body?: SuggestFilesRequestBody;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}/suggest-files';
};

export type PostApiProjectsByProjectIdSuggestFilesErrors = {
    /**
     * Project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error or AI processing error
     */
    500: ApiErrorResponse;
};

export type PostApiProjectsByProjectIdSuggestFilesError = PostApiProjectsByProjectIdSuggestFilesErrors[keyof PostApiProjectsByProjectIdSuggestFilesErrors];

export type PostApiProjectsByProjectIdSuggestFilesResponses = {
    /**
     * Successfully suggested files
     */
    200: SuggestFilesResponse;
};

export type PostApiProjectsByProjectIdSuggestFilesResponse = PostApiProjectsByProjectIdSuggestFilesResponses[keyof PostApiProjectsByProjectIdSuggestFilesResponses];

export type GetApiKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/keys';
};

export type GetApiKeysErrors = {
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiKeysError = GetApiKeysErrors[keyof GetApiKeysErrors];

export type GetApiKeysResponses = {
    /**
     * Successfully retrieved provider keys
     */
    200: ProviderKeyListResponse;
};

export type GetApiKeysResponse = GetApiKeysResponses[keyof GetApiKeysResponses];

export type PostApiKeysData = {
    body: CreateProviderKeyRequestBody;
    path?: never;
    query?: never;
    url: '/api/keys';
};

export type PostApiKeysErrors = {
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiKeysError = PostApiKeysErrors[keyof PostApiKeysErrors];

export type PostApiKeysResponses = {
    /**
     * Provider key created successfully
     */
    201: ProviderKeyResponse;
};

export type PostApiKeysResponse = PostApiKeysResponses[keyof PostApiKeysResponses];

export type DeleteApiKeysByKeyIdData = {
    body?: never;
    path: {
        /**
         * The ID of the provider key
         */
        keyId: string;
    };
    query?: never;
    url: '/api/keys/{keyId}';
};

export type DeleteApiKeysByKeyIdErrors = {
    /**
     * Provider key not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type DeleteApiKeysByKeyIdError = DeleteApiKeysByKeyIdErrors[keyof DeleteApiKeysByKeyIdErrors];

export type DeleteApiKeysByKeyIdResponses = {
    /**
     * Provider key deleted successfully
     */
    200: OperationSuccessResponse;
};

export type DeleteApiKeysByKeyIdResponse = DeleteApiKeysByKeyIdResponses[keyof DeleteApiKeysByKeyIdResponses];

export type GetApiKeysByKeyIdData = {
    body?: never;
    path: {
        /**
         * The ID of the provider key
         */
        keyId: string;
    };
    query?: never;
    url: '/api/keys/{keyId}';
};

export type GetApiKeysByKeyIdErrors = {
    /**
     * Provider key not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiKeysByKeyIdError = GetApiKeysByKeyIdErrors[keyof GetApiKeysByKeyIdErrors];

export type GetApiKeysByKeyIdResponses = {
    /**
     * Successfully retrieved provider key
     */
    200: ProviderKeyResponse;
};

export type GetApiKeysByKeyIdResponse = GetApiKeysByKeyIdResponses[keyof GetApiKeysByKeyIdResponses];

export type PatchApiKeysByKeyIdData = {
    body: UpdateProviderKeyRequestBody;
    path: {
        /**
         * The ID of the provider key
         */
        keyId: string;
    };
    query?: never;
    url: '/api/keys/{keyId}';
};

export type PatchApiKeysByKeyIdErrors = {
    /**
     * Provider key not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PatchApiKeysByKeyIdError = PatchApiKeysByKeyIdErrors[keyof PatchApiKeysByKeyIdErrors];

export type PatchApiKeysByKeyIdResponses = {
    /**
     * Provider key updated successfully
     */
    200: ProviderKeyResponse;
};

export type PatchApiKeysByKeyIdResponse = PatchApiKeysByKeyIdResponses[keyof PatchApiKeysByKeyIdResponses];

export type GetApiStateData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/state';
};

export type GetApiStateErrors = {
    /**
     * Internal Server Error: Failed to read or parse the state from storage.
     */
    500: ApiErrorResponse;
};

export type GetApiStateError = GetApiStateErrors[keyof GetApiStateErrors];

export type GetApiStateResponses = {
    /**
     * Successfully retrieved the current global state.
     */
    200: StateResponse;
};

export type GetApiStateResponse = GetApiStateResponses[keyof GetApiStateResponses];

export type PutApiStateData = {
    /**
     * The complete new global state object.
     */
    body: ReplaceStateBody;
    path?: never;
    query?: never;
    url: '/api/state';
};

export type PutApiStateErrors = {
    /**
     * Bad Request: Validation Error. The provided request body does not conform to the required GlobalState schema structure.
     */
    400: ApiErrorResponse;
    /**
     * Internal Server Error: Failed to write the new state to storage.
     */
    500: ApiErrorResponse;
};

export type PutApiStateError = PutApiStateErrors[keyof PutApiStateErrors];

export type PutApiStateResponses = {
    /**
     * Successfully replaced the global state and returned the new state.
     */
    200: StateResponse;
};

export type PutApiStateResponse = PutApiStateResponses[keyof PutApiStateResponses];

export type PostApiStateSettingsData = {
    body: UpdateSettingsBody;
    path?: never;
    query?: never;
    url: '/api/state/settings';
};

export type PostApiStateSettingsErrors = {
    /**
     * Bad Request: Invalid partial settings data.
     */
    400: ApiErrorResponse;
    /**
     * Internal Server Error: Failed to update settings.
     */
    500: ApiErrorResponse;
};

export type PostApiStateSettingsError = PostApiStateSettingsErrors[keyof PostApiStateSettingsErrors];

export type PostApiStateSettingsResponses = {
    /**
     * Settings updated successfully.
     */
    200: StateResponse;
};

export type PostApiStateSettingsResponse = PostApiStateSettingsResponses[keyof PostApiStateSettingsResponses];

export type PostApiStateActiveProjectTabData = {
    body: SetActiveProjectTabBody;
    path?: never;
    query?: never;
    url: '/api/state/active-project-tab';
};

export type PostApiStateActiveProjectTabErrors = {
    /**
     * Bad Request: Invalid request body.
     */
    400: ApiErrorResponse;
    /**
     * Internal Server Error: Failed to set active project tab.
     */
    500: ApiErrorResponse;
};

export type PostApiStateActiveProjectTabError = PostApiStateActiveProjectTabErrors[keyof PostApiStateActiveProjectTabErrors];

export type PostApiStateActiveProjectTabResponses = {
    /**
     * Active project tab updated successfully.
     */
    200: StateResponse;
};

export type PostApiStateActiveProjectTabResponse = PostApiStateActiveProjectTabResponses[keyof PostApiStateActiveProjectTabResponses];

export type PostApiStateActiveChatData = {
    body: SetActiveChatBody;
    path?: never;
    query?: never;
    url: '/api/state/active-chat';
};

export type PostApiStateActiveChatErrors = {
    /**
     * Bad Request: Invalid request body.
     */
    400: ApiErrorResponse;
    /**
     * Internal Server Error: Failed to set active chat.
     */
    500: ApiErrorResponse;
};

export type PostApiStateActiveChatError = PostApiStateActiveChatErrors[keyof PostApiStateActiveChatErrors];

export type PostApiStateActiveChatResponses = {
    /**
     * Active chat updated successfully.
     */
    200: StateResponse;
};

export type PostApiStateActiveChatResponse = PostApiStateActiveChatResponses[keyof PostApiStateActiveChatResponses];

export type PostApiStateProjectTabsData = {
    body: CreateProjectTabBody;
    path?: never;
    query?: never;
    url: '/api/state/project-tabs';
};

export type PostApiStateProjectTabsErrors = {
    /**
     * Bad Request: Invalid initial tab data.
     */
    400: ApiErrorResponse;
    /**
     * Internal Server Error: Failed to create project tab.
     */
    500: ApiErrorResponse;
};

export type PostApiStateProjectTabsError = PostApiStateProjectTabsErrors[keyof PostApiStateProjectTabsErrors];

export type PostApiStateProjectTabsResponses = {
    /**
     * Project tab created successfully.
     */
    201: CreateProjectTabResponse;
};

export type PostApiStateProjectTabsResponse = PostApiStateProjectTabsResponses[keyof PostApiStateProjectTabsResponses];

export type DeleteApiStateProjectTabsByTabIdData = {
    body?: never;
    path: {
        /**
         * UUID of the project tab to delete.
         */
        tabId: string;
    };
    query?: never;
    url: '/api/state/project-tabs/{tabId}';
};

export type DeleteApiStateProjectTabsByTabIdErrors = {
    /**
     * Bad Request: Invalid tab ID format.
     */
    400: ApiErrorResponse;
    /**
     * Not Found: Project tab with the specified ID does not exist (or was already deleted).
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error: Failed to delete project tab.
     */
    500: ApiErrorResponse;
};

export type DeleteApiStateProjectTabsByTabIdError = DeleteApiStateProjectTabsByTabIdErrors[keyof DeleteApiStateProjectTabsByTabIdErrors];

export type DeleteApiStateProjectTabsByTabIdResponses = {
    /**
     * Project tab deleted successfully.
     */
    200: StateResponse;
};

export type DeleteApiStateProjectTabsByTabIdResponse = DeleteApiStateProjectTabsByTabIdResponses[keyof DeleteApiStateProjectTabsByTabIdResponses];

export type PostApiStateProjectTabsByTabIdData = {
    body: UpdateSingleProjectTabBody;
    path: {
        /**
         * UUID of the project tab to update.
         */
        tabId: string;
    };
    query?: never;
    url: '/api/state/project-tabs/{tabId}';
};

export type PostApiStateProjectTabsByTabIdErrors = {
    /**
     * Bad Request: Invalid partial tab data or invalid tab ID format.
     */
    400: ApiErrorResponse;
    /**
     * Not Found: Project tab with the specified ID does not exist.
     */
    404: ApiErrorResponse;
    /**
     * Internal Server Error: Failed to update project tab.
     */
    500: ApiErrorResponse;
};

export type PostApiStateProjectTabsByTabIdError = PostApiStateProjectTabsByTabIdErrors[keyof PostApiStateProjectTabsByTabIdErrors];

export type PostApiStateProjectTabsByTabIdResponses = {
    /**
     * Project tab updated successfully.
     */
    200: StateResponse;
};

export type PostApiStateProjectTabsByTabIdResponse = PostApiStateProjectTabsByTabIdResponses[keyof PostApiStateProjectTabsByTabIdResponses];

export type PostApiStateProjectTabsReplaceAllData = {
    body: ReplaceProjectTabsBody;
    path?: never;
    query?: never;
    url: '/api/state/project-tabs/replace-all';
};

export type PostApiStateProjectTabsReplaceAllErrors = {
    /**
     * Bad Request: Invalid project tabs record.
     */
    400: ApiErrorResponse;
    /**
     * Internal Server Error: Failed to replace project tabs.
     */
    500: ApiErrorResponse;
};

export type PostApiStateProjectTabsReplaceAllError = PostApiStateProjectTabsReplaceAllErrors[keyof PostApiStateProjectTabsReplaceAllErrors];

export type PostApiStateProjectTabsReplaceAllResponses = {
    /**
     * Project tabs replaced successfully.
     */
    200: StateResponse;
};

export type PostApiStateProjectTabsReplaceAllResponse = PostApiStateProjectTabsReplaceAllResponses[keyof PostApiStateProjectTabsReplaceAllResponses];

export type PostApiStateUpdateData = {
    /**
     * The key-value pair to update in the global state.
     */
    body: UpdateStatePartialBody;
    path?: never;
    query?: never;
    url: '/api/state/update';
};

export type PostApiStateUpdateErrors = {
    /**
     * Bad Request: Validation Error. Occurs if the provided key is invalid, the value type is incorrect for the key, or the resulting state object fails validation according to the GlobalState schema.
     */
    400: ApiErrorResponse;
    /**
     * Internal Server Error: Failed during state update or persistence.
     */
    500: ApiErrorResponse;
};

export type PostApiStateUpdateError = PostApiStateUpdateErrors[keyof PostApiStateUpdateErrors];

export type PostApiStateUpdateResponses = {
    /**
     * Successfully updated the state key and returned the new complete global state.
     */
    200: StateResponse;
};

export type PostApiStateUpdateResponse = PostApiStateUpdateResponses[keyof PostApiStateUpdateResponses];

export type GetApiAdminEnvInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/admin/env-info';
};

export type GetApiAdminEnvInfoErrors = {
    /**
     * Error retrieving environment information
     */
    500: ApiErrorResponse;
};

export type GetApiAdminEnvInfoError = GetApiAdminEnvInfoErrors[keyof GetApiAdminEnvInfoErrors];

export type GetApiAdminEnvInfoResponses = {
    /**
     * Successfully retrieved environment information
     */
    200: EnvInfoResponse;
};

export type GetApiAdminEnvInfoResponse = GetApiAdminEnvInfoResponses[keyof GetApiAdminEnvInfoResponses];

export type GetApiAdminSystemStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/admin/system-status';
};

export type GetApiAdminSystemStatusErrors = {
    /**
     * Error retrieving system status
     */
    500: ApiErrorResponse;
};

export type GetApiAdminSystemStatusError = GetApiAdminSystemStatusErrors[keyof GetApiAdminSystemStatusErrors];

export type GetApiAdminSystemStatusResponses = {
    /**
     * Successfully retrieved system status
     */
    200: SystemStatusResponse;
};

export type GetApiAdminSystemStatusResponse = GetApiAdminSystemStatusResponses[keyof GetApiAdminSystemStatusResponses];

export type PostApiFileAiChangeData = {
    body?: GenerateChangeBody;
    path?: never;
    query?: never;
    url: '/api/file/ai-change';
};

export type PostApiFileAiChangeErrors = {
    /**
     * Invalid request
     */
    400: ApiErrorResponse;
    /**
     * Error generating file change
     */
    500: ApiErrorResponse;
};

export type PostApiFileAiChangeError = PostApiFileAiChangeErrors[keyof PostApiFileAiChangeErrors];

export type PostApiFileAiChangeResponses = {
    /**
     * Successfully generated file change
     */
    200: FileChangeResponse;
};

export type PostApiFileAiChangeResponse = PostApiFileAiChangeResponses[keyof PostApiFileAiChangeResponses];

export type GetApiFileAiChangeByFileChangeIdData = {
    body?: never;
    path: {
        /**
         * ID of the file change
         */
        fileChangeId: string;
    };
    query?: never;
    url: '/api/file/ai-change/{fileChangeId}';
};

export type GetApiFileAiChangeByFileChangeIdErrors = {
    /**
     * Invalid file change ID
     */
    400: ApiErrorResponse;
    /**
     * File change not found
     */
    404: ApiErrorResponse;
    /**
     * Error retrieving file change
     */
    500: ApiErrorResponse;
};

export type GetApiFileAiChangeByFileChangeIdError = GetApiFileAiChangeByFileChangeIdErrors[keyof GetApiFileAiChangeByFileChangeIdErrors];

export type GetApiFileAiChangeByFileChangeIdResponses = {
    /**
     * Successfully retrieved file change
     */
    200: FileChangeDetailsResponse;
};

export type GetApiFileAiChangeByFileChangeIdResponse = GetApiFileAiChangeByFileChangeIdResponses[keyof GetApiFileAiChangeByFileChangeIdResponses];

export type PostApiFileAiChangeByFileChangeIdConfirmData = {
    body?: never;
    path: {
        /**
         * ID of the file change
         */
        fileChangeId: string;
    };
    query?: never;
    url: '/api/file/ai-change/{fileChangeId}/confirm';
};

export type PostApiFileAiChangeByFileChangeIdConfirmErrors = {
    /**
     * Invalid file change ID
     */
    400: ApiErrorResponse;
    /**
     * File change not found
     */
    404: ApiErrorResponse;
    /**
     * Error confirming file change
     */
    500: ApiErrorResponse;
};

export type PostApiFileAiChangeByFileChangeIdConfirmError = PostApiFileAiChangeByFileChangeIdConfirmErrors[keyof PostApiFileAiChangeByFileChangeIdConfirmErrors];

export type PostApiFileAiChangeByFileChangeIdConfirmResponses = {
    /**
     * Successfully confirmed file change
     */
    200: ConfirmChangeResponse;
};

export type PostApiFileAiChangeByFileChangeIdConfirmResponse = PostApiFileAiChangeByFileChangeIdConfirmResponses[keyof PostApiFileAiChangeByFileChangeIdConfirmResponses];

export type GetApiPromptsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/prompts';
};

export type GetApiPromptsErrors = {
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiPromptsError = GetApiPromptsErrors[keyof GetApiPromptsErrors];

export type GetApiPromptsResponses = {
    /**
     * Successfully retrieved all prompts
     */
    200: PromptListResponse;
};

export type GetApiPromptsResponse = GetApiPromptsResponses[keyof GetApiPromptsResponses];

export type PostApiPromptsData = {
    body: CreatePromptRequestBody;
    path?: never;
    query?: never;
    url: '/api/prompts';
};

export type PostApiPromptsErrors = {
    /**
     * Referenced project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiPromptsError = PostApiPromptsErrors[keyof PostApiPromptsErrors];

export type PostApiPromptsResponses = {
    /**
     * Prompt created successfully
     */
    201: PromptResponse;
};

export type PostApiPromptsResponse = PostApiPromptsResponses[keyof PostApiPromptsResponses];

export type GetApiProjectsByProjectIdPromptsData = {
    body?: never;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}/prompts';
};

export type GetApiProjectsByProjectIdPromptsErrors = {
    /**
     * Project not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiProjectsByProjectIdPromptsError = GetApiProjectsByProjectIdPromptsErrors[keyof GetApiProjectsByProjectIdPromptsErrors];

export type GetApiProjectsByProjectIdPromptsResponses = {
    /**
     * Successfully retrieved project prompts
     */
    200: PromptListResponse;
};

export type GetApiProjectsByProjectIdPromptsResponse = GetApiProjectsByProjectIdPromptsResponses[keyof GetApiProjectsByProjectIdPromptsResponses];

export type DeleteApiProjectsByProjectIdPromptsByPromptIdData = {
    body?: never;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
        /**
         * The ID of the prompt
         */
        promptId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}/prompts/{promptId}';
};

export type DeleteApiProjectsByProjectIdPromptsByPromptIdErrors = {
    /**
     * Project or Prompt not found, or association does not exist
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type DeleteApiProjectsByProjectIdPromptsByPromptIdError = DeleteApiProjectsByProjectIdPromptsByPromptIdErrors[keyof DeleteApiProjectsByProjectIdPromptsByPromptIdErrors];

export type DeleteApiProjectsByProjectIdPromptsByPromptIdResponses = {
    /**
     * Prompt successfully disassociated from project
     */
    200: OperationSuccessResponse;
};

export type DeleteApiProjectsByProjectIdPromptsByPromptIdResponse = DeleteApiProjectsByProjectIdPromptsByPromptIdResponses[keyof DeleteApiProjectsByProjectIdPromptsByPromptIdResponses];

export type PostApiProjectsByProjectIdPromptsByPromptIdData = {
    body?: never;
    path: {
        /**
         * The ID of the project
         */
        projectId: string;
        /**
         * The ID of the prompt
         */
        promptId: string;
    };
    query?: never;
    url: '/api/projects/{projectId}/prompts/{promptId}';
};

export type PostApiProjectsByProjectIdPromptsByPromptIdErrors = {
    /**
     * Project or Prompt not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PostApiProjectsByProjectIdPromptsByPromptIdError = PostApiProjectsByProjectIdPromptsByPromptIdErrors[keyof PostApiProjectsByProjectIdPromptsByPromptIdErrors];

export type PostApiProjectsByProjectIdPromptsByPromptIdResponses = {
    /**
     * Prompt successfully associated with project
     */
    200: OperationSuccessResponse;
};

export type PostApiProjectsByProjectIdPromptsByPromptIdResponse = PostApiProjectsByProjectIdPromptsByPromptIdResponses[keyof PostApiProjectsByProjectIdPromptsByPromptIdResponses];

export type DeleteApiPromptsByPromptIdData = {
    body?: never;
    path: {
        /**
         * The UUID of the prompt
         */
        promptId: string;
    };
    query?: never;
    url: '/api/prompts/{promptId}';
};

export type DeleteApiPromptsByPromptIdErrors = {
    /**
     * Prompt not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type DeleteApiPromptsByPromptIdError = DeleteApiPromptsByPromptIdErrors[keyof DeleteApiPromptsByPromptIdErrors];

export type DeleteApiPromptsByPromptIdResponses = {
    /**
     * Prompt deleted successfully
     */
    200: OperationSuccessResponse;
};

export type DeleteApiPromptsByPromptIdResponse = DeleteApiPromptsByPromptIdResponses[keyof DeleteApiPromptsByPromptIdResponses];

export type GetApiPromptsByPromptIdData = {
    body?: never;
    path: {
        /**
         * The UUID of the prompt
         */
        promptId: string;
    };
    query?: never;
    url: '/api/prompts/{promptId}';
};

export type GetApiPromptsByPromptIdErrors = {
    /**
     * Prompt not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type GetApiPromptsByPromptIdError = GetApiPromptsByPromptIdErrors[keyof GetApiPromptsByPromptIdErrors];

export type GetApiPromptsByPromptIdResponses = {
    /**
     * Successfully retrieved prompt
     */
    200: PromptResponse;
};

export type GetApiPromptsByPromptIdResponse = GetApiPromptsByPromptIdResponses[keyof GetApiPromptsByPromptIdResponses];

export type PatchApiPromptsByPromptIdData = {
    body: UpdatePromptRequestBody;
    path: {
        /**
         * The UUID of the prompt
         */
        promptId: string;
    };
    query?: never;
    url: '/api/prompts/{promptId}';
};

export type PatchApiPromptsByPromptIdErrors = {
    /**
     * Prompt not found
     */
    404: ApiErrorResponse;
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error
     */
    500: ApiErrorResponse;
};

export type PatchApiPromptsByPromptIdError = PatchApiPromptsByPromptIdErrors[keyof PatchApiPromptsByPromptIdErrors];

export type PatchApiPromptsByPromptIdResponses = {
    /**
     * Prompt updated successfully
     */
    200: PromptResponse;
};

export type PatchApiPromptsByPromptIdResponse = PatchApiPromptsByPromptIdResponses[keyof PatchApiPromptsByPromptIdResponses];

export type PostApiPromptOptimizeData = {
    /**
     * The user prompt context to optimize
     */
    body: OptimizePromptRequest;
    path?: never;
    query?: never;
    url: '/api/prompt/optimize';
};

export type PostApiPromptOptimizeErrors = {
    /**
     * Validation Error
     */
    422: ApiErrorResponse;
    /**
     * Internal Server Error or AI provider error during optimization
     */
    500: ApiErrorResponse;
};

export type PostApiPromptOptimizeError = PostApiPromptOptimizeErrors[keyof PostApiPromptOptimizeErrors];

export type PostApiPromptOptimizeResponses = {
    /**
     * Successfully optimized the prompt
     */
    200: OptimizePromptResponse;
};

export type PostApiPromptOptimizeResponse = PostApiPromptOptimizeResponses[keyof PostApiPromptOptimizeResponses];

export type ClientOptions = {
    baseUrl: 'http://localhost:3147' | (string & {});
};